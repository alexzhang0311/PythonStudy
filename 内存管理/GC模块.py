'''
导致引用计数+1的情况
对象被创建，并被一个对象引用。a=1
对象被另一个变量引用。b=a
对象被作为参数传递给函数func(a)
对象被添加到容器中，列表，元组，字典，集合中。temp=[a]


导致引用计数-1的情况
引用这个对象的变量被删掉 del a
引用这个对象的变量指向其他对象，a=2
函数作用域执行完毕后。比如函数中的临时变量，在函数执行结束后就会消失。
对象所在容器被销毁，或者容器中删除了这个对象，也会导致这个对象引用计数减1

'''

import gc


#print(gc.set_debug(gc.DEBUG_LEAK))  #查看内存泄露的对象
print(gc.collect(2)) #手动回收垃圾对象，0代表0代，1代表0,1代，2代表0,1,2代
print(gc.get_threshold()) #获取GC模块执行垃圾回收的阈值，分别是0,1,2代的阈值
print(gc.set_threshold(700)) #设置垃圾回收的阈值
print(gc.get_count()) #获取垃圾回收的计数器。0代垃圾对象数量，1是零代链表遍历次数，2是1代链表遍历次数

'''
关于阈值和垃圾回收
gc.get_threshold() 的值是(700,10,10)
零代链表的垃圾对象到达700，就会执行gc.collect(0)，只要一代链表被遍历10次，就会执行gc.collect(1)，只要二代链表被遍历10次，就会执行gc.collect(2)，回收零代，一代以及二代链表中的垃圾对象。


注意点：
gc模块无法处理拥有__del__方法的对象之间存在循环引用，这样gc模块无法对该对象进行回收，会导致内存泄露问题。
'''